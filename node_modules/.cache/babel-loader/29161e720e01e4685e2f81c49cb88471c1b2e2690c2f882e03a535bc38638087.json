{"ast":null,"code":"import _classCallCheck from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nexport var BaseX = /*#__PURE__*/function () {\n  function BaseX(alphabet) {\n    _classCallCheck(this, BaseX);\n    defineReadOnly(this, \"alphabet\", alphabet);\n    defineReadOnly(this, \"base\", alphabet.length);\n    defineReadOnly(this, \"_alphabetMap\", {});\n    defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n    // pre-compute lookup table\n    for (var i = 0; i < alphabet.length; i++) {\n      this._alphabetMap[alphabet.charAt(i)] = i;\n    }\n  }\n  _createClass(BaseX, [{\n    key: \"encode\",\n    value: function encode(value) {\n      var source = arrayify(value);\n      if (source.length === 0) {\n        return \"\";\n      }\n      var digits = [0];\n      for (var i = 0; i < source.length; ++i) {\n        var carry = source[i];\n        for (var j = 0; j < digits.length; ++j) {\n          carry += digits[j] << 8;\n          digits[j] = carry % this.base;\n          carry = carry / this.base | 0;\n        }\n        while (carry > 0) {\n          digits.push(carry % this.base);\n          carry = carry / this.base | 0;\n        }\n      }\n      var string = \"\";\n      // deal with leading zeros\n      for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n        string += this._leader;\n      }\n      // convert digits to a string\n      for (var q = digits.length - 1; q >= 0; --q) {\n        string += this.alphabet[digits[q]];\n      }\n      return string;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(value) {\n      if (typeof value !== \"string\") {\n        throw new TypeError(\"Expected String\");\n      }\n      var bytes = [];\n      if (value.length === 0) {\n        return new Uint8Array(bytes);\n      }\n      bytes.push(0);\n      for (var i = 0; i < value.length; i++) {\n        var byte = this._alphabetMap[value[i]];\n        if (byte === undefined) {\n          throw new Error(\"Non-base\" + this.base + \" character\");\n        }\n        var carry = byte;\n        for (var j = 0; j < bytes.length; ++j) {\n          carry += bytes[j] * this.base;\n          bytes[j] = carry & 0xff;\n          carry >>= 8;\n        }\n        while (carry > 0) {\n          bytes.push(carry & 0xff);\n          carry >>= 8;\n        }\n      }\n      // deal with leading zeros\n      for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n        bytes.push(0);\n      }\n      return arrayify(new Uint8Array(bytes.reverse()));\n    }\n  }]);\n  return BaseX;\n}();\nvar Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nvar Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexport { Base32, Base58 };\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))","map":{"version":3,"mappings":"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","names":["arrayify","defineReadOnly","BaseX","alphabet","length","charAt","i","_alphabetMap","value","source","digits","carry","j","base","push","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base32","Base58"],"sources":["/workspace/Cryptway-ETH-Wallet/node_modules/@ethersproject/basex/src.ts/index.ts"],"sourcesContent":["/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}