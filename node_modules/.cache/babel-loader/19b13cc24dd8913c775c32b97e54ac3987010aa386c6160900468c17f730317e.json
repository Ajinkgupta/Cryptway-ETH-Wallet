{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return hexConcat(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dataLength;\n    }\n  }, {\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data.push(data);\n      this._dataLength += data.length;\n      return data.length;\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n      var paddingOffset = bytes.length % this.wordSize;\n      if (paddingOffset) {\n        bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n      }\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n      return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n      var offset = this._data.length;\n      this._data.push(this._padding);\n      this._dataLength += this.wordSize;\n      return function (value) {\n        _this._data[offset] = _this._getValue(value);\n      };\n    }\n  }]);\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc, allowLoose) {\n    _classCallCheck(this, Reader);\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    }\n    // The default Coerce function\n  }, {\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length, loose) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n      if (this._offset + alignedLength > this._data.length) {\n        if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n          alignedLength = length;\n        } else {\n          logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n            length: this._data.length,\n            offset: this._offset + alignedLength\n          });\n        }\n      }\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = this._peekBytes(0, length, !!loose);\n      this._offset += bytes.length;\n      // @TODO: Make sure the length..end bytes are all 0?\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n      return value;\n    }\n  }]);\n  return Reader;\n}();","map":{"version":3,"mappings":"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","names":["arrayify","concat","hexConcat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","name","type","localName","dynamic","message","value","throwArgumentError","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","data","length","writer","_writeData","bytes","paddingOffset","from","throwError","BUFFER_OVERRUN","offset","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","Math","ceil","_peekBytes","readBytes","match","parseInt","toNumber"],"sources":["/workspace/Cryptway-ETH-Wallet/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}