{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/workspace/Cryptway-ETH-Wallet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\nimport { Coder } from \"./abstract-coder\";\nexport var NumberCoder = /*#__PURE__*/function (_Coder) {\n  _inherits(NumberCoder, _Coder);\n  var _super = _createSuper(NumberCoder);\n  function NumberCoder(size, signed, localName) {\n    var _this;\n    _classCallCheck(this, NumberCoder);\n    var name = (signed ? \"int\" : \"uint\") + size * 8;\n    _this = _super.call(this, name, name, localName, false);\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n  _createClass(NumberCoder, [{\n    key: \"defaultValue\",\n    value: function defaultValue() {\n      return 0;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      var v = BigNumber.from(value);\n      // Check bounds are safe for encoding\n      var maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n      if (this.signed) {\n        var bounds = maxUintValue.mask(this.size * 8 - 1);\n        if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n          this._throwError(\"value out-of-bounds\", value);\n        }\n      } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n        this._throwError(\"value out-of-bounds\", value);\n      }\n      v = v.toTwos(this.size * 8).mask(this.size * 8);\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n      }\n      return writer.writeValue(v);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(reader) {\n      var value = reader.readValue().mask(this.size * 8);\n      if (this.signed) {\n        value = value.fromTwos(this.size * 8);\n      }\n      return reader.coerce(this.name, value);\n    }\n  }]);\n  return NumberCoder;\n}(Coder);","map":{"version":3,"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AAAA;AAEb,SAASA,SAAS,QAAsB,0BAA0B;AAClE,SAASC,UAAU,EAAEC,WAAW,EAAEC,GAAG,EAAEC,IAAI,QAAQ,0BAA0B;AAE7E,SAASC,KAAK,QAAwB,kBAAkB;AAExD,WAAaC,WAAY;EAAA;EAAA;EAIrB,qBAAYC,IAAY,EAAEC,MAAe,EAAEC,SAAiB;IAAA;IAAA;IACxD,IAAMC,IAAI,GAAI,CAACF,MAAM,GAAG,KAAK,GAAE,MAAM,IAAKD,IAAI,GAAG,CAAG;IACpD,0BAAMG,IAAI,EAAEA,IAAI,EAAED,SAAS,EAAE,KAAK;IAElC,MAAKF,IAAI,GAAGA,IAAI;IAChB,MAAKC,MAAM,GAAGA,MAAM;IAAC;EACzB;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,CAAC;IACZ;EAAC;IAAA;IAAA,OAED,gBAAOG,MAAc,EAAEC,KAAmB;MACtC,IAAIC,CAAC,GAAGb,SAAS,CAACc,IAAI,CAACF,KAAK,CAAC;MAE7B;MACA,IAAIG,YAAY,GAAGd,UAAU,CAACe,IAAI,CAACL,MAAM,CAACM,QAAQ,GAAG,CAAC,CAAC;MACvD,IAAI,IAAI,CAACT,MAAM,EAAE;QACb,IAAIU,MAAM,GAAGH,YAAY,CAACC,IAAI,CAAC,IAAI,CAACT,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;QACjD,IAAIM,CAAC,CAACM,EAAE,CAACD,MAAM,CAAC,IAAIL,CAAC,CAACO,EAAE,CAACF,MAAM,CAACG,GAAG,CAAClB,GAAG,CAAC,CAACmB,GAAG,CAACpB,WAAW,CAAC,CAAC,EAAE;UACxD,IAAI,CAACqB,WAAW,CAAC,qBAAqB,EAAEX,KAAK,CAAC;;OAErD,MAAM,IAAIC,CAAC,CAACO,EAAE,CAAChB,IAAI,CAAC,IAAIS,CAAC,CAACM,EAAE,CAACJ,YAAY,CAACC,IAAI,CAAC,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;QAC7D,IAAI,CAACgB,WAAW,CAAC,qBAAqB,EAAEX,KAAK,CAAC;;MAGlDC,CAAC,GAAGA,CAAC,CAACW,MAAM,CAAC,IAAI,CAACjB,IAAI,GAAG,CAAC,CAAC,CAACS,IAAI,CAAC,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;MAE/C,IAAI,IAAI,CAACC,MAAM,EAAE;QACbK,CAAC,GAAGA,CAAC,CAACY,QAAQ,CAAC,IAAI,CAAClB,IAAI,GAAG,CAAC,CAAC,CAACiB,MAAM,CAAC,CAAC,GAAGb,MAAM,CAACM,QAAQ,CAAC;;MAG7D,OAAON,MAAM,CAACe,UAAU,CAACb,CAAC,CAAC;IAC/B;EAAC;IAAA;IAAA,OAED,gBAAOc,MAAc;MACjB,IAAIf,KAAK,GAAGe,MAAM,CAACC,SAAS,EAAE,CAACZ,IAAI,CAAC,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;MAElD,IAAI,IAAI,CAACC,MAAM,EAAE;QACbI,KAAK,GAAGA,KAAK,CAACa,QAAQ,CAAC,IAAI,CAAClB,IAAI,GAAG,CAAC,CAAC;;MAGzC,OAAOoB,MAAM,CAACE,MAAM,CAAC,IAAI,CAACnB,IAAI,EAAEE,KAAK,CAAC;IAC1C;EAAC;EAAA;AAAA,EA/C4BP,KAAK","names":["BigNumber","MaxUint256","NegativeOne","One","Zero","Coder","NumberCoder","size","signed","localName","name","writer","value","v","from","maxUintValue","mask","wordSize","bounds","gt","lt","add","mul","_throwError","toTwos","fromTwos","writeValue","reader","readValue","coerce"],"sources":["/workspace/Cryptway-ETH-Wallet/node_modules/@ethersproject/abi/src.ts/coders/number.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}